### 浏览器渲染，每个页面单独加载，每有url的变化变会有新的服务器请求
   1. 加载：根据请求的url进行域名解析，向服务器发送请求，接收文件（html,css,js,img等）
   2. 解析：从Html解析出DOM tree，解析css产生css规则树（计算css），js,通过DOM api和css api操作dom tree和css rule tree

### 利用html hash实现切换
  1. 实际上是单页面的显示和隐藏的操作，无法操作浏览器的物理返回键，并不是真正的hash跳转
  2. 可以模拟浏览器的hash变化，即当一个新页面进入时，给当前地址加上一个#hash 的标识，当点击物理返回键的时候，这个hash值会发生变化(回退到上一个hash)，与此同时也会触发一个hashchange事件，当监听到hash变化时，我们就通过JS切换上一个hash对应的页面，这样就实现了物理返回键的效果。
   3. 同一页面的显示和隐藏，当刷新页面的时候会回到初始化这个页面中，所有的页面内容的替换与操作都是通过js，不利于seo优化
    
### 服务端渲染
指传统的asp,java,或php的渲染机制
  优势：
    1. 不需要先下载一堆js和css后才能看到页面（首屏性能）
    2. SEO
    3. 减少客户端的电量消耗

### 基于Vue和React的SPA
  前端渲染：使用js来渲染页面大部分内容
  优势：
    1. 局部刷新，无需每次都进行页面完整请求
    2. 懒加载，在页面初始化时只加载可视区域内的书，滚动后按需加载其他数据
    3. 富交互，使用js实现各种炫酷效果
    4. 解决服务器成功，
  缺点：
      1. 首屏性能
      2. SEO：传统的搜索引擎只会从html中抓取数据，导致前端渲染的页面无法被抓取。前端渲染通过使用的SPA会把所有的js整体打包，无法忽视的问题就是文件太大，导致渲染前等待时间很长，特别是网速差的时候，让用户等待白屏结束体验不好

### 基于Vue的nuxt.js 和 基于React的next.js 的同构渲染
  同构渲染：前后端公用js,首次渲染时使用Node.js输出html，通过渲染介于前后端中的共有部分
  优点：
  1. 有助于SEO
  2. 公用前端代码，节省开发时间
    并没有节省前端的开发量，只是把一部分代码拿到服务端执行
  3. 提高首屏性能
    由于 SPA 打包生成的 JS 往往都比较大，会导致页面加载后花费很长的时间来解析，也就造成了白屏问题。服务端渲染可以预先使到数据并渲染成最终 HTML 直接展示，理想情况下能避免白屏问题。在我参考过的一些产品中，很多页面需要获取十几个接口的数据，单是数据获取的时候都会花费数秒钟，这样全部使用同构反而会变慢。
  缺点：
    1. 性能，由原来的大量浏览器端的工作转换到几台服务器上
    2. 不容忽视的服务器端和浏览器端的环境差异
        * window,document等对象找不到的问题，window在node环境是不存在的，
        * DOM计算报错的问题
        * 前端渲染和服务器端渲染内容不一致的问题
    3. 内存溢出，前端代码由于浏览器环境重新刷新一遍内存重置的天然优势，对内存溢出的风险并没有考虑充分。比如在React的`componentWillMount`里做绑定事件就会发生内存溢出，因为React的设计是后端渲染只会运行`componentDidMount`之前的操作，而不会运行`componentWillMount`方法
    4. 异步操作 

 #### 浏览器的主要功能
  将用户选择的web资源呈现出来，需要从服务器请求资源，并将其展示在浏览器窗口中，资源的格式通常是html,pdf,img及其他格式。用户用url来指定请求资源的位置，通过dns查询，将网址转为ip地址，整个浏览器的工作过程:
>> 1. 输入网址
>> 2. 浏览器检查域名的ip地址
>> 3. 浏览器给web服务器发送一个http请求
>> 4. 服务器响应请求，浏览器显示html,解析并构建成一颗dom树
>> 5. 浏览器发送请求css,js,img等资源文件
>> 6. 服务器响应


